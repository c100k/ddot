package output

import (
	"c100k/ddot/rsrc"
	"c100k/ddot/ui"
	"errors"
	"fmt"
	"os"
	"strings"
	"time"
)

const SEP = "#===============================================================================\n"
const PREFIX = "#======>"
const SECTION_SEP = "\n\n"

const PERM = 0600

func Clean(out string) error {
	ui.Print("ðŸ§½", fmt.Sprintf("Removing %s", out))

	err := os.Remove(out)

	return err
}

func Exists(out string) (bool, error) {
	_, err := os.Stat(out)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return false, nil
		}

		return true, err
	}

	return true, nil
}

func Write(out string, resources []*rsrc.Resource) error {
	count := len(resources)
	ui.Print("ðŸ’¾", fmt.Sprintf("Writing %d resources to %s", count, out))

	var builder strings.Builder

	now := time.Now().Local().UTC()

	builder.WriteString(SEP)
	builder.WriteString(fmt.Sprintf("%s [DO NOT EDIT]\n", PREFIX))
	builder.WriteString(fmt.Sprintf("%s file generated by ddot\n", PREFIX))
	builder.WriteString(fmt.Sprintf("%s at %s\n", PREFIX, now))
	builder.WriteString(SEP)
	builder.WriteString(SECTION_SEP)

	for i, resource := range resources {
		builder.WriteString(SEP)
		builder.WriteString(fmt.Sprintf("%s from resource at '%s'\n", PREFIX, resource.Uri))
		builder.WriteString(SEP)
		builder.WriteString(strings.TrimSpace(*resource.Content))

		if i < count-1 {
			builder.WriteString(SECTION_SEP)
		}
	}

	builder.WriteString("\n")

	err := os.WriteFile(out, []byte(builder.String()), PERM)
	if err != nil {
		return err
	}

	ui.PrintSuccess(fmt.Sprintf("File %s written successfully", out))

	return nil
}
